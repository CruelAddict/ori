
// Code generated by @open-rpc/generator DO NOT EDIT.
import {
  RequestManager,
  PostMessageWindowTransport,
  PostMessageIframeTransport,
  WebSocketTransport,
  HTTPTransport,
  Client,
  JSONRPCError,
} from "@open-rpc/client-js";
import _ from "lodash";
import {
  OpenrpcDocument as OpenRPC,
  MethodObject,
} from "@open-rpc/meta-schema";
import {
  MethodCallValidator,
  MethodNotFoundError,
  parseOpenRPCDocument,
} from "@open-rpc/schema-utils-js";

/**
 *
 * Connection name from configuration
 *
 */
export type StringMt4FlmeX = string;
/**
 *
 * Human-readable connection name
 *
 */
export type StringSZpdTXHE = string;
/**
 *
 * Database type (mysql, postgresql, etc.)
 *
 */
export type StringVc4ApXED = string;
/**
 *
 * Database host address
 *
 */
export type StringOlqPwczy = string;
/**
 *
 * Database port number
 *
 */
export type IntegerLz1UwwG4 = number;
/**
 *
 * Database name
 *
 */
export type StringErJ2QyX2 = string;
/**
 *
 * Database username
 *
 */
export type String1Ac98OeC = string;
/**
 *
 * Password provider type
 *
 */
export type StringCsUvb1AD = "plain_text" | "macos-keychain";
/**
 *
 * The key/value for password retrieval
 *
 */
export type StringXRxQBYhT = string;
/**
 *
 * Password retrieval configuration
 *
 */
export interface ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUS {
  type: StringCsUvb1AD;
  key: StringXRxQBYhT;
  [k: string]: any;
}
export interface ObjectOfString1Ac98OeCStringVc4ApXEDIntegerLz1UwwG4ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUSStringSZpdTXHEStringOlqPwczyStringErJ2QyX2WrpyYBUS {
  name: StringSZpdTXHE;
  type: StringVc4ApXED;
  host: StringOlqPwczy;
  port: IntegerLz1UwwG4;
  database: StringErJ2QyX2;
  username: String1Ac98OeC;
  password: ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUS;
  [k: string]: any;
}
/**
 *
 * Array of database connection configurations
 *
 */
export type UnorderedSetOfObjectOfString1Ac98OeCStringVc4ApXEDIntegerLz1UwwG4ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUSStringSZpdTXHEStringOlqPwczyStringErJ2QyX2WrpyYBUSwrpyYBUS = ObjectOfString1Ac98OeCStringVc4ApXEDIntegerLz1UwwG4ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUSStringSZpdTXHEStringOlqPwczyStringErJ2QyX2WrpyYBUS[];
export type StringBFCLQyc2 = "success" | "fail" | "connecting";
/**
 *
 * Optional message for the user
 *
 */
export type StringQHG7IjOg = string;
export interface ObjectOfStringMt4FlmeX55Q21Zjl {
  configurationName: StringMt4FlmeX;
  [k: string]: any;
}
export interface ObjectOfUnorderedSetOfObjectOfString1Ac98OeCStringVc4ApXEDIntegerLz1UwwG4ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUSStringSZpdTXHEStringOlqPwczyStringErJ2QyX2WrpyYBUSwrpyYBUSWrpyYBUS {
  connections: UnorderedSetOfObjectOfString1Ac98OeCStringVc4ApXEDIntegerLz1UwwG4ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUSStringSZpdTXHEStringOlqPwczyStringErJ2QyX2WrpyYBUSwrpyYBUS;
  [k: string]: any;
}
export interface ObjectOfStringQHG7IjOgStringBFCLQyc2IHaGdl5F {
  result: StringBFCLQyc2;
  userMessage?: StringQHG7IjOg;
  [k: string]: any;
}
/**
 *
 * Generated! Represents an alias to any of the provided schemas
 *
 */
export type AnyOfObjectOfStringMt4FlmeX55Q21ZjlObjectOfUnorderedSetOfObjectOfString1Ac98OeCStringVc4ApXEDIntegerLz1UwwG4ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUSStringSZpdTXHEStringOlqPwczyStringErJ2QyX2WrpyYBUSwrpyYBUSWrpyYBUSObjectOfStringQHG7IjOgStringBFCLQyc2IHaGdl5F = ObjectOfStringMt4FlmeX55Q21Zjl | ObjectOfUnorderedSetOfObjectOfString1Ac98OeCStringVc4ApXEDIntegerLz1UwwG4ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUSStringSZpdTXHEStringOlqPwczyStringErJ2QyX2WrpyYBUSwrpyYBUSWrpyYBUS | ObjectOfStringQHG7IjOgStringBFCLQyc2IHaGdl5F;
export type ListConfigurations = () => Promise<ObjectOfUnorderedSetOfObjectOfString1Ac98OeCStringVc4ApXEDIntegerLz1UwwG4ObjectOfStringCsUvb1ADStringXRxQBYhTWrpyYBUSStringSZpdTXHEStringOlqPwczyStringErJ2QyX2WrpyYBUSwrpyYBUSWrpyYBUS>;
export type Connect = (connection: ObjectOfStringMt4FlmeX55Q21Zjl) => Promise<ObjectOfStringQHG7IjOgStringBFCLQyc2IHaGdl5F>;

export interface Options {
  transport: {
    type: "websocket" | "http" | "https" | "postmessagewindow" | "postmessageiframe";
    host: string;
    port: number;
    path?: string;
    protocol?: string;
  };
}

export class OriDatabaseExplorerAPI {
  public rpc: Client;
  public static openrpcDocument: OpenRPC = {"openrpc":"1.3.2","info":{"title":"Ori Database Explorer API","description":"JSON-RPC API for exploring database configurations and metadata","version":"1.0.0"},"methods":[{"name":"listConfigurations","summary":"List all database configurations","description":"Returns a list of all configured database connections from the server configuration file","params":[],"result":{"name":"ConfigurationsResult","description":"List of database connection configurations","schema":{"$ref":"#/components/schemas/ConfigurationsResult"}}},{"name":"connect","summary":"Open a database connection by configuration name","description":"If the connection already exists, returns success. Otherwise starts connecting asynchronously and returns connecting.","params":[{"name":"connection","schema":{"$ref":"#/components/schemas/ConnectParams"}}],"result":{"name":"ConnectResult","schema":{"$ref":"#/components/schemas/ConnectResult"}}}],"components":{"schemas":{"ConfigurationsResult":{"type":"object","properties":{"connections":{"type":"array","description":"Array of database connection configurations","items":{"$ref":"#/components/schemas/ConnectionConfig"}}},"required":["connections"]},"ConnectionConfig":{"type":"object","properties":{"name":{"type":"string","description":"Human-readable connection name"},"type":{"type":"string","description":"Database type (mysql, postgresql, etc.)"},"host":{"type":"string","description":"Database host address"},"port":{"type":"integer","description":"Database port number"},"database":{"type":"string","description":"Database name"},"username":{"type":"string","description":"Database username"},"password":{"$ref":"#/components/schemas/PasswordConfig"}},"required":["name","type","host","port","database","username","password"]},"PasswordConfig":{"type":"object","description":"Password retrieval configuration","properties":{"type":{"type":"string","description":"Password provider type","enum":["plain_text","macos-keychain"]},"key":{"type":"string","description":"The key/value for password retrieval"}},"required":["type","key"]},"ConnectParams":{"type":"object","properties":{"configurationName":{"type":"string","description":"Connection name from configuration"}},"required":["configurationName"]},"ConnectResult":{"type":"object","properties":{"result":{"type":"string","enum":["success","fail","connecting"]},"userMessage":{"type":"string","description":"Optional message for the user"}},"required":["result"]}}}};
  public dereffedDocument: OpenRPC | undefined;
  public transport:
    | HTTPTransport
    | WebSocketTransport
    | PostMessageWindowTransport
    | PostMessageIframeTransport;
  private validator: MethodCallValidator | undefined;
  private timeout: number | undefined;

  constructor(options: Options) {
    if (
      options.transport === undefined ||
      options.transport.type === undefined
    ) {
      throw new Error("Invalid constructor params");
    }
    const { type, host, port, protocol } = options.transport;
    let path = options.transport.path || "";
    if (path && path[0] !== "/") {
      path = "/" + path;
    }
    switch (type) {
      case 'http':
      case 'https':
        this.transport = new HTTPTransport(
          (protocol || type) + "://" + host + ":" + port + path
        );
        break;
      case 'websocket':
        this.transport = new WebSocketTransport(
          (protocol || "ws://") + host + ":" + port + path
        );
        break;
      case 'postmessageiframe':
        this.transport = new PostMessageIframeTransport(
          protocol + "://" + host + ":" + port + path
        );
        break;
      case 'postmessagewindow':
        this.transport = new PostMessageWindowTransport(
          protocol + "://" + host + ":" + port + path
        );
        break;
      default:
        throw new Error("unsupported transport");
    }
    this.rpc = new Client(new RequestManager([this.transport]));
  }

  /**
   * Adds a JSONRPC notification handler to handle receiving notifications.
   * @example
   * myClient.onNotification((data)=>console.log(data));
   */
  private async initialize() {
    if (this.validator) {
      return;
    }
    this.dereffedDocument = await parseOpenRPCDocument(OriDatabaseExplorerAPI.openrpcDocument);
    this.validator = new MethodCallValidator(this.dereffedDocument);
  }

  /**
   * Adds a JSONRPC notification handler to handle receiving notifications.
   * @example
   * myClient.onNotification((data)=>console.log(data));
   */
  public onNotification(callback: (data: any) => void) {
    this.rpc.onNotification(callback);
  }

  /**
   * Adds an optional JSONRPCError handler to handle receiving errors that cannot be resolved to a specific request
   * @example
   * myClient.onError((err: JSONRPCError)=>console.log(err.message));
   */
  public onError(callback: (data: JSONRPCError) => void) {
    this.rpc.onError(callback);
  }

  /**
   * Sets a default timeout in ms for all requests excluding notifications.
   * @example
   * // 20s timeout
   * myClient.setDefaultTimeout(20000);
   * // Removes timeout from request
   * myClient.setDefaultTimeout(undefined);
   */
  public setDefaultTimeout(ms?: number) {
    this.timeout = ms;
  }

  /**
   * Initiates [[OriDatabaseExplorerAPI.startBatch]] in order to build a batch call.
   *
   * Subsequent calls to [[OriDatabaseExplorerAPI.request]] will be added to the batch.
   * Once [[OriDatabaseExplorerAPI.stopBatch]] is called, the promises for the [[OriDatabaseExplorerAPI.request]]
   * will then be resolved.  If there is already a batch in progress this method is a noop.
   *
   * @example
   * myClient.startBatch();
   * myClient.foo().then(() => console.log("foobar"))
   * myClient.bar().then(() => console.log("foobarbaz"))
   * myClient.stopBatch();
   */
  public startBatch(): void {
    return this.rpc.startBatch();
  }

  /**
   * Initiates [[Client.stopBatch]] in order to finalize and send the batch to the underlying transport.
   *
   * stopBatch will send the [[OriDatabaseExplorerAPI]] calls made since the last [[OriDatabaseExplorerAPI.startBatch]] call. For
   * that reason, [[OriDatabaseExplorerAPI.startBatch]] MUST be called before [[OriDatabaseExplorerAPI.stopBatch]].
   *
   * @example
   * myClient.startBatch();
   * myClient.foo().then(() => console.log("foobar"))
   * myClient.bar().then(() => console.log("foobarbaz"))
   * myClient.stopBatch();
   */
  public stopBatch(): void {
    return this.rpc.stopBatch();
  }

  private async request(methodName: string, params: any[]): Promise<any> {
    await this.initialize();
    if (this.validator === undefined) {
      throw new Error("internal error");
    }
    const methodObject = _.find(
      (OriDatabaseExplorerAPI.openrpcDocument.methods as MethodObject[]),
      ({ name }) => name === methodName
    ) as MethodObject;
    const notification = methodObject.result ? false : true;
    const openRpcMethodValidationErrors = this.validator.validate(
      methodName,
      params
    );
    if (
      openRpcMethodValidationErrors instanceof MethodNotFoundError ||
      openRpcMethodValidationErrors.length > 0
    ) {
      return Promise.reject(openRpcMethodValidationErrors);
    }

    let rpcParams;
    if (
      methodObject.paramStructure &&
      methodObject.paramStructure === "by-name"
    ) {
      rpcParams = _.zipObject(_.map(methodObject.params, "name"), params);
    } else {
      rpcParams = params;
    }
    if (notification) {
      return this.rpc.notify({ method: methodName, params: rpcParams });
    }
    return this.rpc.request(
      { method: methodName, params: rpcParams },
      this.timeout
    );
  }

  
  /**
   * List all database configurations
   */
  // tslint:disable-next-line:max-line-length
  public listConfigurations: ListConfigurations = (...params) => {
    return this.request("listConfigurations", params);
  }
  
  /**
   * Open a database connection by configuration name
   */
  // tslint:disable-next-line:max-line-length
  public connect: Connect = (...params) => {
    return this.request("connect", params);
  }
  
}
export default OriDatabaseExplorerAPI;
