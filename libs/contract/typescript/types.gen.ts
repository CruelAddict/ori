// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'http://localhost:8080' | (string & {});
};

export type PasswordConfig = {
    /**
     * Password provider type
     */
    type: 'plain_text' | 'shell' | 'keychain';
    /**
     * Provider-specific identifier (plain text value, shell command, or keychain account)
     */
    key: string;
};

export type TlsConfig = {
    /**
     * TLS mode (e.g. require, verify-ca, verify-full)
     */
    mode?: string | null;
    /**
     * CA certificate path
     */
    caCertPath?: string | null;
    /**
     * Client certificate path
     */
    certPath?: string | null;
    /**
     * Client key path
     */
    keyPath?: string | null;
};

export type Configuration = {
    name: string;
    type: string;
    host?: string | null;
    port?: number | null;
    database: string;
    username?: string | null;
    password?: PasswordConfig;
    tls?: TlsConfig;
};

export type ConfigurationsResponse = {
    connections: Array<Configuration>;
};

export type ConnectionRequest = {
    configurationName: string;
};

export type ConnectionResult = {
    result: 'success' | 'fail' | 'connecting';
    userMessage?: string | null;
};

export type NodeEdge = {
    items: Array<string>;
    truncated: boolean;
};

export type DatabaseNodeAttributes = {
    connection: string;
    engine: string;
    isDefault: boolean;
    file?: string;
    sequence?: number;
    pageSize?: number;
    encoding?: string;
};

export type SchemaNodeAttributes = {
    connection: string;
    engine: string;
    isDefault: boolean;
};

export type TableNodeAttributes = {
    connection: string;
    table: string;
    tableType: string;
    definition?: string;
};

export type ViewNodeAttributes = {
    connection: string;
    table: string;
    tableType: string;
    definition?: string;
};

export type ColumnNodeAttributes = {
    connection: string;
    table: string;
    column: string;
    ordinal: number;
    dataType: string;
    notNull: boolean;
    defaultValue?: string;
    primaryKeyPosition?: number;
    charMaxLength?: number;
    numericPrecision?: number;
    numericScale?: number;
};

export type ConstraintNodeAttributes = {
    connection: string;
    table: string;
    constraintName: string;
    constraintType: string;
    columns?: Array<string>;
    referencedTable?: string;
    referencedDatabase?: string;
    referencedSchema?: string;
    referencedColumns?: Array<string>;
    onUpdate?: string;
    onDelete?: string;
    match?: string;
    indexName?: string;
    checkClause?: string;
};

export type IndexNodeAttributes = {
    connection: string;
    table: string;
    indexName: string;
    unique: boolean;
    primary: boolean;
    columns?: Array<string>;
    includeColumns?: Array<string>;
    definition?: string;
    method?: string;
    predicate?: string;
};

export type TriggerNodeAttributes = {
    connection: string;
    table: string;
    triggerName: string;
    timing: string;
    orientation: string;
    events?: Array<string>;
    statement?: string;
    condition?: string;
    enabledState?: string;
    definition?: string;
};

export type NodeBase = {
    id: string;
    name: string;
    edges: {
        [key: string]: NodeEdge;
    };
};

export type DatabaseNode = NodeBase & {
    type: 'database';
    attributes: DatabaseNodeAttributes;
};

export type SchemaNode = NodeBase & {
    type: 'schema';
    attributes: SchemaNodeAttributes;
};

export type TableNode = NodeBase & {
    type: 'table';
    attributes: TableNodeAttributes;
};

export type ViewNode = NodeBase & {
    type: 'view';
    attributes: ViewNodeAttributes;
};

export type ColumnNode = NodeBase & {
    type: 'column';
    attributes: ColumnNodeAttributes;
};

export type ConstraintNode = NodeBase & {
    type: 'constraint';
    attributes: ConstraintNodeAttributes;
};

export type IndexNode = NodeBase & {
    type: 'index';
    attributes: IndexNodeAttributes;
};

export type TriggerNode = NodeBase & {
    type: 'trigger';
    attributes: TriggerNodeAttributes;
};

export type Node = ({
    type: 'database';
} & DatabaseNode) | ({
    type: 'schema';
} & SchemaNode) | ({
    type: 'table';
} & TableNode) | ({
    type: 'view';
} & ViewNode) | ({
    type: 'column';
} & ColumnNode) | ({
    type: 'constraint';
} & ConstraintNode) | ({
    type: 'index';
} & IndexNode) | ({
    type: 'trigger';
} & TriggerNode);

export type NodesResponse = {
    nodes: Array<Node>;
};

export type QueryExecOptions = {
    maxRows?: number;
};

export type QueryExecRequest = {
    configurationName: string;
    jobId: string;
    query: string;
    params?: {
        [key: string]: unknown;
    } | Array<unknown>;
    options?: QueryExecOptions;
};

export type QueryExecResponse = {
    jobId: string;
    status: 'running' | 'failed';
    message?: string | null;
};

export type QueryResultColumn = {
    name: string;
    type: string;
};

export type QueryResultResponse = {
    columns: Array<QueryResultColumn>;
    rows: Array<Array<unknown>>;
    rowCount: number;
    truncated: boolean;
    rowsAffected?: number | null;
};

export type ErrorPayload = {
    code: string;
    message: string;
    details?: {
        [key: string]: unknown;
    };
};

export type GetHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type GetHealthErrors = {
    /**
     * Generic error payload
     */
    default: ErrorPayload;
};

export type GetHealthError = GetHealthErrors[keyof GetHealthErrors];

export type GetHealthResponses = {
    /**
     * Backend is ready to accept requests
     */
    200: string;
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type ListConfigurationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/configurations';
};

export type ListConfigurationsErrors = {
    /**
     * Generic error payload
     */
    default: ErrorPayload;
};

export type ListConfigurationsError = ListConfigurationsErrors[keyof ListConfigurationsErrors];

export type ListConfigurationsResponses = {
    /**
     * Collection of saved configurations
     */
    200: ConfigurationsResponse;
};

export type ListConfigurationsResponse = ListConfigurationsResponses[keyof ListConfigurationsResponses];

export type StartConnectionData = {
    body: ConnectionRequest;
    path?: never;
    query?: never;
    url: '/connections';
};

export type StartConnectionErrors = {
    /**
     * Configuration not found
     */
    404: ErrorPayload;
    /**
     * Connection is already in progress and cannot be restarted yet
     */
    409: ErrorPayload;
    /**
     * Generic error payload
     */
    default: ErrorPayload;
};

export type StartConnectionError = StartConnectionErrors[keyof StartConnectionErrors];

export type StartConnectionResponses = {
    /**
     * Connection attempt accepted
     */
    201: ConnectionResult;
};

export type StartConnectionResponse = StartConnectionResponses[keyof StartConnectionResponses];

export type GetNodesData = {
    body?: never;
    path: {
        /**
         * Name of the configuration to inspect
         */
        configurationName: string;
    };
    query?: {
        /**
         * Optional repeated parameter limiting the nodes returned
         */
        nodeId?: Array<string>;
    };
    url: '/configurations/{configurationName}/nodes';
};

export type GetNodesErrors = {
    /**
     * Configuration not found
     */
    404: ErrorPayload;
    /**
     * Generic error payload
     */
    default: ErrorPayload;
};

export type GetNodesError = GetNodesErrors[keyof GetNodesErrors];

export type GetNodesResponses = {
    /**
     * Matching schema nodes
     */
    200: NodesResponse;
};

export type GetNodesResponse = GetNodesResponses[keyof GetNodesResponses];

export type ExecQueryData = {
    body: QueryExecRequest;
    path?: never;
    query?: never;
    url: '/queries';
};

export type ExecQueryErrors = {
    /**
     * Configuration not found or no active connection
     */
    404: ErrorPayload;
    /**
     * Generic error payload
     */
    default: ErrorPayload;
};

export type ExecQueryError = ExecQueryErrors[keyof ExecQueryErrors];

export type ExecQueryResponses = {
    /**
     * Query accepted and job created
     */
    202: QueryExecResponse;
};

export type ExecQueryResponse = ExecQueryResponses[keyof ExecQueryResponses];

export type CancelQueryData = {
    body?: never;
    path: {
        jobId: string;
    };
    query?: never;
    url: '/queries/{jobId}/cancel';
};

export type CancelQueryErrors = {
    /**
     * Job not found
     */
    404: ErrorPayload;
    /**
     * Generic error payload
     */
    default: ErrorPayload;
};

export type CancelQueryError = CancelQueryErrors[keyof CancelQueryErrors];

export type CancelQueryResponses = {
    /**
     * Cancel request accepted
     */
    202: {
        status: string;
    };
};

export type CancelQueryResponse = CancelQueryResponses[keyof CancelQueryResponses];

export type GetQueryResultData = {
    body?: never;
    path: {
        jobId: string;
    };
    query?: {
        limit?: number;
        offset?: number;
    };
    url: '/queries/{jobId}/result';
};

export type GetQueryResultErrors = {
    /**
     * Job not found
     */
    404: ErrorPayload;
    /**
     * Generic error payload
     */
    default: ErrorPayload;
};

export type GetQueryResultError = GetQueryResultErrors[keyof GetQueryResultErrors];

export type GetQueryResultResponses = {
    /**
     * Result view for the job
     */
    200: QueryResultResponse;
};

export type GetQueryResultResponse = GetQueryResultResponses[keyof GetQueryResultResponses];

export type StreamEventsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/events';
};

export type StreamEventsErrors = {
    /**
     * Generic error payload
     */
    default: ErrorPayload;
};

export type StreamEventsError = StreamEventsErrors[keyof StreamEventsErrors];

export type StreamEventsResponses = {
    /**
     * Stream of events in SSE format
     */
    200: string;
};

export type StreamEventsResponse = StreamEventsResponses[keyof StreamEventsResponses];
